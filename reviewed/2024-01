
URL reference: https://kubernetes.io/docs/concepts/containers/images/#use-cases
DateReviewed: 2024-01-01
Description: This is the Kubernetes docs, specifically the area on repositories. It's actually a little confusing, because one of the use cases is actually an example of not needing a private repo -- everything is open source code. It then goes on to explain how to set up a private repo and what controllers you need to ensure you arbitrate access correctly -- you may not want certain pods to run outside of specific nodes. It's a few paragraphs inside of a much larger doc, but the private registry parts are decent.
BottomLine: Good explaination of how to run private repos for images in Kubernetes
==
URL reference: https://twitter.com/hisomraj/status/1742040731534172404
DateReviewed: 2024-01-02
Description: It's an inforgraphic, so let's go. It's on Kubernetes security, and tells you what not to ignore. It covers RBAC, Pod Security, Network policies, Encryption and Logging as seperate points. Each point has 2 bullets, so not too much is covered on each area. All of the points are very high level, and the illustration level is not very high for a visual medium. There points are all solid, so it's a good quick overview.
BottomLine: Infographic that is a decent high-level toe dip to Kubernetes security
==
URL reference: https://fixyacloud.com/kubernetes/exploring-the-power-of-kubectl-dry-run-client-and-server-command-examples
DateReviewed: 2024-01-03
Description: Our article is going to tackle what the "dry run" command is and how to use it. We start with a definition, where they explain the dry run command shows you what the impact of your change would be, without actually making any actual changes to Kubernetes resources. We then review the client-side version of dry run, which just shows you what commands would be sent to the back end. The more interesting bit is sending them to the server, which is done with a different flag, and we'll be told how this would impact the cluster. They then explain how to run through the process, and include a couple of quick examples. It would be helpful if they'd done a bit more on the example side, but this is adequate for an intro.
BottomLine: Decent intro to the Kubernetes dry run command and some examples
==
URL reference: https://www.devopsroles.com/installing-kubernetes-using-kubeadm-on-ubuntu/
DateReviewed: 2024-01-04
Description: This article will walk us through installing Kubeadm on Ubuntu. We're going to be using 2 worker and 1 master nodes in this scenario. The then walk us through some config details for the setup, and mention we need to disable swap and set up bridging (which then include instructions for). We have to install Docker, to have a container runner, so they take us through that, including having it run. Next we go through the Kubernetes bits we need, including Kubeadm, Kubelet and Kubectl. Once the configs are done and everything is installed, we start our Kubernetes for the first time, with "kubeadm init". There is another bit of housekeeping on the master, and then we start spinning up the workers, by cut and pasting the output from the master spinup. Finally, we can check that our cluster is running. Now, this is a basic guide, but does a good job of touching all the points.
BottomLine: Good walkthrough on how to get Kubernetes installed on Ubuntu
==
URL reference: https://www.tigera.io/blog/deep-dive/deploy-multi-tenant-red-hat-openshift-clusters-with-calicos-namespace-and-workload-isolation/
DateReviewed: 2024-01-05
Description: Containers good but security bad to start, what a unique opening. This time, we're going to focus on Calico to get our security helping done. Typically all of your pods share one network segment, and what we're doing here will produce isolated micro-segments. Let's dig in. For Kubernetes, we use the CNI, or Container Network Interface which sets up the pod networks. CNIs work to plug the pods in, but don't contain a policy engine -- K8s comes with a native one that allows network policies to be set. Our area here is OpenShift, so we'll use that to create our Network Policies through a YAML file. We can code the YAML directly, or the suggestion is to you OpenShift's GUI to create one. We're then introduced to Calico, and they have a 5 paragraph blurb about what Calico does. So, spinning up a default OpenShift cluster starts 60 namespaces and services and has hundreds of pods running -- ouch. Helpfully Calico has a graph to show you the interconnections in a visual way, and our authors tell us that not every pod should be able to talk to all the others -- but that is the default. There is a way to gather the comms paths and view proposed policies, but it's important a DevSecOps person review them. They then do show the visualization tool does show traffic and it's associated policies, which allows you to ensure all traffic is covered properly. It's a bit complicated, but it does seem like an interesting approach.
BottomLine: Decent mid-level walkthrough of a microsegmentation approach to Kubernetes
==
URL reference: https://www.kubernetes.dev/blog/2024/01/05/kube-proxy-non-privileged/
DateReviewed: 2024-01-06
Description: Our post here will show how to run kube-proxy in a seperate container. Usually, to run kube-proxy we need our container to be "privileged", but usually we don't want our workloads to run in such privileged containers. So, what to do? In this case, they are leveraging the fact that in init containers we can set sysctls and then not need the container to run with privilege. They then run through the YAML that would be needed to set up such a situation, and explain that by using the --init-only flag it has the desired effect. Now personally, I've only used kube-proxy for quick checks or debugging, but I see where it might be helpful -- but I think best practice would be to expose a service. Still a neat technique.
BottomLine: Interesting way to run Kube-proxy on Kubernetes without needing privileges
==
URL reference: https://www.bsmithio.com/post/baremetal-k8s/
DateReviewed: 2024-01-07
Description: This is a guide to getting a specific version of baremetal K8s working. They are going to install ono top of Ubuntu 20.04, and we start with a recent version of Docker. They then pull down things to support, like the CLI and containerd. We tweak the configs and start Docker, then install the Kubernetes utilities, including kubectl, kubelet and kubeadm. We then set up the configs (and decide if we want to run K8s as root), and then set up the Network bits. They then explain how to enable running pods on the master node, if you should want to run a single-node cluster. Next they explain how to set up worker nodes, including how to join the cluster. They then go through the setup of MetalLB, so you can have a non-cloud based LB. The final step is the Ingress controller, which allows traffic to come into our cluster. To test things, they show us how to create a test app and deploy the associated pod. They then explain how to connect ingress to our app, and how to get things working with our hosts file. They also show how to get TLS working, which is helpful. As extras, they include refs to external-dns, cert-manager and k8s_gateway. Overall, a strong guide.
BottomLine: Good walkthrough on setting up a local bare metal Kubernetes
==
