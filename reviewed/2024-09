
URL reference: https://www.youtube.com/watch?app=desktop&v=Ltf5cBzWlxU
DateReviewed: 2024-09-01
Description: This vid covers eBPF in about 2 minutes. First, we start going through the Linux kernel, and how it works at a basic level. Then, they pose the question - what if we want to change something in the kernel, and go through why we might want that. They say changing the kernel is hard, but we can use this cool thing called eBPF to do it. They then explain how eBPF programs are run inside a kernel VM. Basically, the VM system allows the compiler/toolchain to verify what is being done by the eBPF program, to ensure it only does things we want it to. High level but informative, this is a great intro to eBPF.
BottomLine: Great 2 minute intro to eBPF in the Linux kernel
==
URL reference: https://www.armosec.io/blog/ebpf-reverse-engineering-programs/
DateReviewed: 2024-09-01
Description: It seems that instead of using kernel modules, many companies are now using eBPF to do kernel related actions, and this article will look into that and how to break down a program that is intended to be run by eBPF. We start with an intro to eBPF, explaining how using eBPF is similar to a kernel module, and how it is run with a JIT compiler and in a sandbox environment. A verifier checks the program before running, constraining what can be done. To actually run a program, you need to have your code compiled by a compatible complier, and Clang is a popular option. The VM that is used contains registers, and they break down how they are divided up and what they do. They also go through the layout of Opcodes and a few examples so you can understand the layout. They then describe how you would actually get a BPF program to run, and how the kernel actually handles this. We then go through some of the setups and use-cases for eBPF. They note that a BPF program has access to and the potential to change privleged information, so care must be taken; they also note that there is a tight stack limit which must be kept in mind. They explain that eBPF is primarily event based, so the prinicipal way it interacts is to register hooks that get called with info passed to them. We have a diagram showing the call flow of various processes. They then spend a section explaining the verifier and how it works, breaking it down in detail, as it adds some quirks to how the flow works in an eBPF program. We finally arrive at reversing, and they pick a rootkit and go through an example. They find where it hooks, do a simple disassembly and step through, explaining all of the lines. They work through macros and function calls, breaking it all down. After the analysis, they explain that this program modifys and logs program execution. They then show the original source. What a great read.
BottomLine: Fantastic intro to eBPF and eBPF reversing
==
URL reference: https://chanaka-supun.medium.com/demystifying-service-mesh-on-kubernetes-533ec9974626
DateReviewed: 2024-09-02
Description: This article will talk about service mesh, and we start with a diagram, so that is promising. Next up is the motivator, why do we need a service mesh. They point out that a monolith runs all code in a single binary and can simply invoke a function call, where microservices might need to call out to each other to achieve the same call, needing network communications to work. There are a number of concerns, including security, capacity, availability and authentication. A service mesh can help bring these under control. Next up we dive into what is service mesh, which seperates networking parts from biz logic parts. One container does the network, and another the biz logic, but all in one pod -- the sidecar pattern. We then dig into how service mesh does this - starting with predefined policies for security and routing. The mesh creates the sidecar when a pod is created, and handles all of the setup/redirects for the logic container. We then look at some  Mesh providers, namely Istio and Anthos. They do a bit of a deeper dive on Istio, explaining how the different pieces work. We conclude with a demo of service mesh on GKE, utilizing a small e-commerce app. We then pivot back and cover traffic management with Service mesh. Overall a decent piece, just oddly organized.
BottomLine: Interesting piece explaining Service Mesh on Kubernetes, with a simple demo walkthrough
==
URL reference: https://medium.com/@sudhakarak30/end-to-end-ci-cd-pipeline-implementation-36713766f923
DateReviewed: 2024-09-03
Description: So, this is a walkthrough of setting up Jenkins. It's broken down into steps, and there are a LOT of them. Like, too many (39 parts) -- I think breaking this into a couple broad parts might have been a bit more approachable. We start with a diagram, always a bonus. There is a long list of prereqs, and a bit of background on the author using Minkube to deploy a Java app. Then, we're into the steps. The steps are all small, and they include screenshots or output as needed. The first few steps is firing up VMs and prepping, followed by installing and getting Jenkins to run. Next is configuring Jenkins through the web UI, and installing some plugins for the build process, like Docker. Then we go through the process of hooking up a Docker hub account to Jenkins, to action the build process. We pause for a primer on Jenkins stages, so you know how the build flows; we're up to part 26 at this point. Next they go through spinning up Kubernetes and ArgoCD, and they end with a Java spring boot app built using Maven. Pretty impressive.
BottomLine: Longish but detailed walkthrough on setting up Jenkins with Kubernetes
==
URL reference: https://fenyuk.medium.com/kubernetes-operator-create-the-one-with-kubebuilder-5d1ac240d0d4
DateReviewed: 2024-09-04
Description: This article talks about how Operators can be used to customize Kubernetes, and how to actually build them to accomplish this. In the early motivation, it talks a bit about how the pieces play together and what the Operators high level role here is. We start with a reference URL to an intro to Kubernetes Operators, as the article intends to focus on development. To get started quickeer, he's going to base his dev on something he did in a previous installment, which he also references. Interestingly, the approach here is to help facilitate testing, namely tuning an app to have the right memory limits based on a load, which is being load tested with the purpose of eliminating out of memory errors. The intention here is to use the Operator to tune this; if a pod/container dies with an OOM error, bump up the memory limit and ENV info and try again. Gotta love the diagram, explaining the flow. He does note that this is probably not a best practices, but it is an interesting approach and usage. He then explains what is needed; namely a CRD or custom resource definition, to set up a memory limit, and a CR or custom resource to actually define that limit, along with an app to test it on and an operator to manage it. He'll use Kubebuilder as the dev tool. He assumes we've successfully installed Kubebuilder already, so only has to initialize and configure a new project to get started; it sets up the strtucture and gives us some sample Golang code and scripts. He shows the output, and then walks through configuring the CRD in the operator code and walks through the generated YAML file. Next up is the CR with a specific limit, which will actually be used in our pod. There is some CLI bits which deploy this into our K8s cluster. He adds some code to log for the Operator, and then deploys this to make sure the Operator is working in our cluster as we desire. Once this is done, he adds some code to actually do the memory bump if we got an OOM error, and adds it as a call from the code we've already deployed, and also mentions this is run once a minute. He then runs his load simulator and watches the output, showing the pod hitting an OOM error and the Operator bumping up the memory limit to try again. Overall a good walkthrough showing a few different areas of how Kubernetes works along with deploying and using an Operator.
BottomLine: Great hands on for Operator development showing a few areas of Kubernetes pretty well
==
